{"ast":null,"code":"import { useEffect } from 'react';\nimport useCommittedRef from './useCommittedRef';\n/**\r\n * Creates a `setInterval` that is properly cleaned up when a component unmounted\r\n *\r\n * ```tsx\r\n *  function Timer() {\r\n *    const [timer, setTimer] = useState(0)\r\n *    useInterval(() => setTimer(i => i + 1), 1000)\r\n *\r\n *    return <span>{timer} seconds past</span>\r\n *  }\r\n * ```\r\n *\r\n * @param fn an function run on each interval\r\n * @param ms The milliseconds duration of the interval\r\n */\n\nfunction useInterval(fn, ms, paused, runImmediately) {\n  if (paused === void 0) {\n    paused = false;\n  }\n\n  if (runImmediately === void 0) {\n    runImmediately = false;\n  }\n\n  var handle;\n  var fnRef = useCommittedRef(fn); // this ref is necessary b/c useEffect will sometimes miss a paused toggle\n  // orphaning a setTimeout chain in the aether, so relying on it's refresh logic is not reliable.\n\n  var pausedRef = useCommittedRef(paused);\n\n  var tick = function tick() {\n    if (pausedRef.current) return;\n    fnRef.current();\n    schedule(); // eslint-disable-line no-use-before-define\n  };\n\n  var schedule = function schedule() {\n    clearTimeout(handle);\n    handle = setTimeout(tick, ms);\n  };\n\n  useEffect(function () {\n    if (runImmediately) {\n      tick();\n    } else {\n      schedule();\n    }\n\n    return function () {\n      return clearTimeout(handle);\n    };\n  }, [paused, runImmediately]);\n}\n\nexport default useInterval;","map":{"version":3,"sources":["C:/Users/bhupe/Downloads/Term 4/COMP4537/MilestoneFinal/ISAproject/node_modules/@restart/hooks/esm/useInterval.js"],"names":["useEffect","useCommittedRef","useInterval","fn","ms","paused","runImmediately","handle","fnRef","pausedRef","tick","current","schedule","clearTimeout","setTimeout"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAT,CAAqBC,EAArB,EAAyBC,EAAzB,EAA6BC,MAA7B,EAAqCC,cAArC,EAAqD;AACnD,MAAID,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrBA,IAAAA,MAAM,GAAG,KAAT;AACD;;AAED,MAAIC,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAC7BA,IAAAA,cAAc,GAAG,KAAjB;AACD;;AAED,MAAIC,MAAJ;AACA,MAAIC,KAAK,GAAGP,eAAe,CAACE,EAAD,CAA3B,CAVmD,CAUlB;AACjC;;AAEA,MAAIM,SAAS,GAAGR,eAAe,CAACI,MAAD,CAA/B;;AAEA,MAAIK,IAAI,GAAG,SAASA,IAAT,GAAgB;AACzB,QAAID,SAAS,CAACE,OAAd,EAAuB;AACvBH,IAAAA,KAAK,CAACG,OAAN;AACAC,IAAAA,QAAQ,GAHiB,CAGb;AACb,GAJD;;AAMA,MAAIA,QAAQ,GAAG,SAASA,QAAT,GAAoB;AACjCC,IAAAA,YAAY,CAACN,MAAD,CAAZ;AACAA,IAAAA,MAAM,GAAGO,UAAU,CAACJ,IAAD,EAAON,EAAP,CAAnB;AACD,GAHD;;AAKAJ,EAAAA,SAAS,CAAC,YAAY;AACpB,QAAIM,cAAJ,EAAoB;AAClBI,MAAAA,IAAI;AACL,KAFD,MAEO;AACLE,MAAAA,QAAQ;AACT;;AAED,WAAO,YAAY;AACjB,aAAOC,YAAY,CAACN,MAAD,CAAnB;AACD,KAFD;AAGD,GAVQ,EAUN,CAACF,MAAD,EAASC,cAAT,CAVM,CAAT;AAWD;;AAED,eAAeJ,WAAf","sourcesContent":["import { useEffect } from 'react';\r\nimport useCommittedRef from './useCommittedRef';\r\n/**\r\n * Creates a `setInterval` that is properly cleaned up when a component unmounted\r\n *\r\n * ```tsx\r\n *  function Timer() {\r\n *    const [timer, setTimer] = useState(0)\r\n *    useInterval(() => setTimer(i => i + 1), 1000)\r\n *\r\n *    return <span>{timer} seconds past</span>\r\n *  }\r\n * ```\r\n *\r\n * @param fn an function run on each interval\r\n * @param ms The milliseconds duration of the interval\r\n */\r\n\r\nfunction useInterval(fn, ms, paused, runImmediately) {\r\n  if (paused === void 0) {\r\n    paused = false;\r\n  }\r\n\r\n  if (runImmediately === void 0) {\r\n    runImmediately = false;\r\n  }\r\n\r\n  var handle;\r\n  var fnRef = useCommittedRef(fn); // this ref is necessary b/c useEffect will sometimes miss a paused toggle\r\n  // orphaning a setTimeout chain in the aether, so relying on it's refresh logic is not reliable.\r\n\r\n  var pausedRef = useCommittedRef(paused);\r\n\r\n  var tick = function tick() {\r\n    if (pausedRef.current) return;\r\n    fnRef.current();\r\n    schedule(); // eslint-disable-line no-use-before-define\r\n  };\r\n\r\n  var schedule = function schedule() {\r\n    clearTimeout(handle);\r\n    handle = setTimeout(tick, ms);\r\n  };\r\n\r\n  useEffect(function () {\r\n    if (runImmediately) {\r\n      tick();\r\n    } else {\r\n      schedule();\r\n    }\r\n\r\n    return function () {\r\n      return clearTimeout(handle);\r\n    };\r\n  }, [paused, runImmediately]);\r\n}\r\n\r\nexport default useInterval;"]},"metadata":{},"sourceType":"module"}