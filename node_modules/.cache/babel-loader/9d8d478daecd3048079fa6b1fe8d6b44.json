{"ast":null,"code":"/** @license React v0.20.2\r\n * scheduler-tracing.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\n\n    var interactionIDCounter = 0;\n    var threadIDCounter = 0; // Set of currently traced interactions.\n    // Interactions \"stack\"–\n    // Meaning that newly traced interactions are appended to the previously active set.\n    // When an interaction goes out of scope, the previous set (if any) is restored.\n\n    exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\n\n    exports.__subscriberRef = null;\n    {\n      exports.__interactionsRef = {\n        current: new Set()\n      };\n      exports.__subscriberRef = {\n        current: null\n      };\n    }\n\n    function unstable_clear(callback) {\n      var prevInteractions = exports.__interactionsRef.current;\n      exports.__interactionsRef.current = new Set();\n\n      try {\n        return callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n      }\n    }\n\n    function unstable_getCurrent() {\n      {\n        return exports.__interactionsRef.current;\n      }\n    }\n\n    function unstable_getThreadID() {\n      return ++threadIDCounter;\n    }\n\n    function unstable_trace(name, timestamp, callback) {\n      var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n      var interaction = {\n        __count: 1,\n        id: interactionIDCounter++,\n        name: name,\n        timestamp: timestamp\n      };\n      var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\n      // To do that, clone the current interactions.\n      // The previous set will be restored upon completion.\n\n      var interactions = new Set(prevInteractions);\n      interactions.add(interaction);\n      exports.__interactionsRef.current = interactions;\n      var subscriber = exports.__subscriberRef.current;\n      var returnValue;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onInteractionTraced(interaction);\n        }\n      } finally {\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStarted(interactions, threadID);\n          }\n        } finally {\n          try {\n            returnValue = callback();\n          } finally {\n            exports.__interactionsRef.current = prevInteractions;\n\n            try {\n              if (subscriber !== null) {\n                subscriber.onWorkStopped(interactions, threadID);\n              }\n            } finally {\n              interaction.__count--; // If no async work was scheduled for this interaction,\n              // Notify subscribers that it's completed.\n\n              if (subscriber !== null && interaction.__count === 0) {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              }\n            }\n          }\n        }\n      }\n\n      return returnValue;\n    }\n\n    function unstable_wrap(callback) {\n      var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n      var wrappedInteractions = exports.__interactionsRef.current;\n      var subscriber = exports.__subscriberRef.current;\n\n      if (subscriber !== null) {\n        subscriber.onWorkScheduled(wrappedInteractions, threadID);\n      } // Update the pending async work count for the current interactions.\n      // Update after calling subscribers in case of error.\n\n\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count++;\n      });\n      var hasRun = false;\n\n      function wrapped() {\n        var prevInteractions = exports.__interactionsRef.current;\n        exports.__interactionsRef.current = wrappedInteractions;\n        subscriber = exports.__subscriberRef.current;\n\n        try {\n          var returnValue;\n\n          try {\n            if (subscriber !== null) {\n              subscriber.onWorkStarted(wrappedInteractions, threadID);\n            }\n          } finally {\n            try {\n              returnValue = callback.apply(undefined, arguments);\n            } finally {\n              exports.__interactionsRef.current = prevInteractions;\n\n              if (subscriber !== null) {\n                subscriber.onWorkStopped(wrappedInteractions, threadID);\n              }\n            }\n          }\n\n          return returnValue;\n        } finally {\n          if (!hasRun) {\n            // We only expect a wrapped function to be executed once,\n            // But in the event that it's executed more than once–\n            // Only decrement the outstanding interaction counts once.\n            hasRun = true; // Update pending async counts for all wrapped interactions.\n            // If this was the last scheduled async work for any of them,\n            // Mark them as completed.\n\n            wrappedInteractions.forEach(function (interaction) {\n              interaction.__count--;\n\n              if (subscriber !== null && interaction.__count === 0) {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              }\n            });\n          }\n        }\n      }\n\n      wrapped.cancel = function cancel() {\n        subscriber = exports.__subscriberRef.current;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkCanceled(wrappedInteractions, threadID);\n          }\n        } finally {\n          // Update pending async counts for all wrapped interactions.\n          // If this was the last scheduled async work for any of them,\n          // Mark them as completed.\n          wrappedInteractions.forEach(function (interaction) {\n            interaction.__count--;\n\n            if (subscriber && interaction.__count === 0) {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            }\n          });\n        }\n      };\n\n      return wrapped;\n    }\n\n    var subscribers = null;\n    {\n      subscribers = new Set();\n    }\n\n    function unstable_subscribe(subscriber) {\n      {\n        subscribers.add(subscriber);\n\n        if (subscribers.size === 1) {\n          exports.__subscriberRef.current = {\n            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n            onInteractionTraced: onInteractionTraced,\n            onWorkCanceled: onWorkCanceled,\n            onWorkScheduled: onWorkScheduled,\n            onWorkStarted: onWorkStarted,\n            onWorkStopped: onWorkStopped\n          };\n        }\n      }\n    }\n\n    function unstable_unsubscribe(subscriber) {\n      {\n        subscribers.delete(subscriber);\n\n        if (subscribers.size === 0) {\n          exports.__subscriberRef.current = null;\n        }\n      }\n    }\n\n    function onInteractionTraced(interaction) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onInteractionTraced(interaction);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n\n    function onInteractionScheduledWorkCompleted(interaction) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n\n    function onWorkScheduled(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkScheduled(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n\n    function onWorkStarted(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkStarted(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n\n    function onWorkStopped(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkStopped(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n\n    function onWorkCanceled(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkCanceled(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n\n    exports.unstable_clear = unstable_clear;\n    exports.unstable_getCurrent = unstable_getCurrent;\n    exports.unstable_getThreadID = unstable_getThreadID;\n    exports.unstable_subscribe = unstable_subscribe;\n    exports.unstable_trace = unstable_trace;\n    exports.unstable_unsubscribe = unstable_unsubscribe;\n    exports.unstable_wrap = unstable_wrap;\n  })();\n}","map":{"version":3,"sources":["C:/Users/bhupe/Downloads/Term 4/COMP4537/FinalMilestone/ISAproject/node_modules/scheduler/cjs/scheduler-tracing.development.js"],"names":["process","env","NODE_ENV","DEFAULT_THREAD_ID","interactionIDCounter","threadIDCounter","exports","__interactionsRef","__subscriberRef","current","Set","unstable_clear","callback","prevInteractions","unstable_getCurrent","unstable_getThreadID","unstable_trace","name","timestamp","threadID","arguments","length","undefined","interaction","__count","id","interactions","add","subscriber","returnValue","onInteractionTraced","onWorkStarted","onWorkStopped","onInteractionScheduledWorkCompleted","unstable_wrap","wrappedInteractions","onWorkScheduled","forEach","hasRun","wrapped","apply","cancel","onWorkCanceled","subscribers","unstable_subscribe","size","unstable_unsubscribe","delete","didCatchError","caughtError","error"],"mappings":"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","sourcesContent":["/** @license React v0.20.2\r\n * scheduler-tracing.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\r\n\r\nvar interactionIDCounter = 0;\r\nvar threadIDCounter = 0; // Set of currently traced interactions.\r\n// Interactions \"stack\"–\r\n// Meaning that newly traced interactions are appended to the previously active set.\r\n// When an interaction goes out of scope, the previous set (if any) is restored.\r\n\r\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\r\n\r\nexports.__subscriberRef = null;\r\n\r\n{\r\n  exports.__interactionsRef = {\r\n    current: new Set()\r\n  };\r\n  exports.__subscriberRef = {\r\n    current: null\r\n  };\r\n}\r\nfunction unstable_clear(callback) {\r\n\r\n  var prevInteractions = exports.__interactionsRef.current;\r\n  exports.__interactionsRef.current = new Set();\r\n\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    exports.__interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\nfunction unstable_getCurrent() {\r\n  {\r\n    return exports.__interactionsRef.current;\r\n  }\r\n}\r\nfunction unstable_getThreadID() {\r\n  return ++threadIDCounter;\r\n}\r\nfunction unstable_trace(name, timestamp, callback) {\r\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\r\n\r\n  var interaction = {\r\n    __count: 1,\r\n    id: interactionIDCounter++,\r\n    name: name,\r\n    timestamp: timestamp\r\n  };\r\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\r\n  // To do that, clone the current interactions.\r\n  // The previous set will be restored upon completion.\r\n\r\n  var interactions = new Set(prevInteractions);\r\n  interactions.add(interaction);\r\n  exports.__interactionsRef.current = interactions;\r\n  var subscriber = exports.__subscriberRef.current;\r\n  var returnValue;\r\n\r\n  try {\r\n    if (subscriber !== null) {\r\n      subscriber.onInteractionTraced(interaction);\r\n    }\r\n  } finally {\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      }\r\n    } finally {\r\n      try {\r\n        returnValue = callback();\r\n      } finally {\r\n        exports.__interactionsRef.current = prevInteractions;\r\n\r\n        try {\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(interactions, threadID);\r\n          }\r\n        } finally {\r\n          interaction.__count--; // If no async work was scheduled for this interaction,\r\n          // Notify subscribers that it's completed.\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return returnValue;\r\n}\r\nfunction unstable_wrap(callback) {\r\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\r\n\r\n  var wrappedInteractions = exports.__interactionsRef.current;\r\n  var subscriber = exports.__subscriberRef.current;\r\n\r\n  if (subscriber !== null) {\r\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\r\n  } // Update the pending async work count for the current interactions.\r\n  // Update after calling subscribers in case of error.\r\n\r\n\r\n  wrappedInteractions.forEach(function (interaction) {\r\n    interaction.__count++;\r\n  });\r\n  var hasRun = false;\r\n\r\n  function wrapped() {\r\n    var prevInteractions = exports.__interactionsRef.current;\r\n    exports.__interactionsRef.current = wrappedInteractions;\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      var returnValue;\r\n\r\n      try {\r\n        if (subscriber !== null) {\r\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\r\n        }\r\n      } finally {\r\n        try {\r\n          returnValue = callback.apply(undefined, arguments);\r\n        } finally {\r\n          exports.__interactionsRef.current = prevInteractions;\r\n\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\r\n          }\r\n        }\r\n      }\r\n\r\n      return returnValue;\r\n    } finally {\r\n      if (!hasRun) {\r\n        // We only expect a wrapped function to be executed once,\r\n        // But in the event that it's executed more than once–\r\n        // Only decrement the outstanding interaction counts once.\r\n        hasRun = true; // Update pending async counts for all wrapped interactions.\r\n        // If this was the last scheduled async work for any of them,\r\n        // Mark them as completed.\r\n\r\n        wrappedInteractions.forEach(function (interaction) {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapped.cancel = function cancel() {\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\r\n      }\r\n    } finally {\r\n      // Update pending async counts for all wrapped interactions.\r\n      // If this was the last scheduled async work for any of them,\r\n      // Mark them as completed.\r\n      wrappedInteractions.forEach(function (interaction) {\r\n        interaction.__count--;\r\n\r\n        if (subscriber && interaction.__count === 0) {\r\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  return wrapped;\r\n}\r\n\r\nvar subscribers = null;\r\n\r\n{\r\n  subscribers = new Set();\r\n}\r\n\r\nfunction unstable_subscribe(subscriber) {\r\n  {\r\n    subscribers.add(subscriber);\r\n\r\n    if (subscribers.size === 1) {\r\n      exports.__subscriberRef.current = {\r\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\r\n        onInteractionTraced: onInteractionTraced,\r\n        onWorkCanceled: onWorkCanceled,\r\n        onWorkScheduled: onWorkScheduled,\r\n        onWorkStarted: onWorkStarted,\r\n        onWorkStopped: onWorkStopped\r\n      };\r\n    }\r\n  }\r\n}\r\nfunction unstable_unsubscribe(subscriber) {\r\n  {\r\n    subscribers.delete(subscriber);\r\n\r\n    if (subscribers.size === 0) {\r\n      exports.__subscriberRef.current = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction onInteractionTraced(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionTraced(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onInteractionScheduledWorkCompleted(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkScheduled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStarted(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStarted(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStopped(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStopped(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkCanceled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkCanceled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nexports.unstable_clear = unstable_clear;\r\nexports.unstable_getCurrent = unstable_getCurrent;\r\nexports.unstable_getThreadID = unstable_getThreadID;\r\nexports.unstable_subscribe = unstable_subscribe;\r\nexports.unstable_trace = unstable_trace;\r\nexports.unstable_unsubscribe = unstable_unsubscribe;\r\nexports.unstable_wrap = unstable_wrap;\r\n  })();\r\n}\r\n"]},"metadata":{},"sourceType":"script"}