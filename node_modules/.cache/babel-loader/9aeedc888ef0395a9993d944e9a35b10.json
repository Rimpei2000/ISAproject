{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/bhupe/Downloads/Term 4/COMP4537/MilestoneFinal/ISAproject/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"C:/Users/bhupe/Downloads/Term 4/COMP4537/MilestoneFinal/ISAproject/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/bhupe/Downloads/Term 4/COMP4537/MilestoneFinal/ISAproject/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/bhupe/Downloads/Term 4/COMP4537/MilestoneFinal/ISAproject/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { transformToViewState, applyViewStateToTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nvar pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nvar cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nvar otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nvar settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nvar handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\n\nvar Mapbox = /*#__PURE__*/function () {\n  function Mapbox(MapClass, props, container) {\n    var _this = this;\n\n    _classCallCheck(this, Mapbox);\n\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null; // Internal states\n\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n\n    this._onEvent = function (e) {\n      // @ts-ignore\n      var cb = _this.props[otherEvents[e.type]];\n\n      if (cb) {\n        cb(e);\n      }\n    };\n\n    this._onPointerEvent = function (e) {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        _this._updateHover(e);\n      } // @ts-ignore\n\n\n      var cb = _this.props[pointerEvents[e.type]];\n\n      if (cb) {\n        if (_this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          var features = _this._hoveredFeatures || _this._map.queryRenderedFeatures(e.point, {\n            layers: _this.props.interactiveLayerIds\n          });\n\n          if (!features.length) {\n            return;\n          }\n\n          e.features = features;\n        }\n\n        cb(e);\n        delete e.features;\n      }\n    };\n\n    this._onCameraEvent = function (e) {\n      if (!_this._internalUpdate) {\n        // @ts-ignore\n        var cb = _this.props[cameraEvents[e.type]];\n\n        if (cb) {\n          cb(e);\n        }\n      }\n\n      if (e.type in _this._deferredEvents) {\n        _this._deferredEvents[e.type] = false;\n      }\n    };\n\n    this._MapClass = MapClass;\n    this.props = props;\n\n    this._initialize(container);\n  }\n\n  _createClass(Mapbox, [{\n    key: \"map\",\n    get: function get() {\n      return this._map;\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this._renderTransform;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      var oldProps = this.props;\n      this.props = props;\n\n      var settingsChanged = this._updateSettings(props, oldProps);\n\n      if (settingsChanged) {\n        this._renderTransform = this._map.transform.clone();\n      }\n\n      var sizeChanged = this._updateSize(props);\n\n      var viewStateChanged = this._updateViewState(props, true);\n\n      this._updateStyle(props, oldProps);\n\n      this._updateStyleComponents(props, oldProps);\n\n      this._updateHandlers(props, oldProps); // If 1) view state has changed to match props and\n      //    2) the props change is not triggered by map events,\n      // it's driven by an external state change. Redraw immediately\n\n\n      if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value:\n    /* eslint-disable complexity,max-statements */\n    function _initialize(container) {\n      var _this2 = this;\n\n      var props = this.props;\n\n      var mapOptions = _objectSpread(_objectSpread(_objectSpread({}, props), props.initialViewState), {}, {\n        accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n        container: container,\n        style: normalizeStyle(props.mapStyle)\n      });\n\n      var viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n      Object.assign(mapOptions, {\n        center: [viewState.longitude || 0, viewState.latitude || 0],\n        zoom: viewState.zoom || 0,\n        pitch: viewState.pitch || 0,\n        bearing: viewState.bearing || 0\n      });\n\n      if (props.gl) {\n        // eslint-disable-next-line\n        var getContext = HTMLCanvasElement.prototype.getContext; // Hijack canvas.getContext to return our own WebGLContext\n        // This will be called inside the mapboxgl.Map constructor\n        // @ts-expect-error\n\n        HTMLCanvasElement.prototype.getContext = function () {\n          // Unhijack immediately\n          HTMLCanvasElement.prototype.getContext = getContext;\n          return props.gl;\n        };\n      }\n\n      var map = new this._MapClass(mapOptions); // Props that are not part of constructor options\n\n      if (viewState.padding) {\n        map.setPadding(viewState.padding);\n      }\n\n      if (props.cursor) {\n        map.getCanvas().style.cursor = props.cursor;\n      }\n\n      this._renderTransform = map.transform.clone(); // Hack\n      // Insert code into map's render cycle\n\n      var renderMap = map._render;\n\n      map._render = function (arg) {\n        _this2._inRender = true;\n        renderMap.call(map, arg);\n        _this2._inRender = false;\n      };\n\n      var runRenderTaskQueue = map._renderTaskQueue.run;\n\n      map._renderTaskQueue.run = function (arg) {\n        runRenderTaskQueue.call(map._renderTaskQueue, arg);\n\n        _this2._onBeforeRepaint();\n      };\n\n      map.on('render', function () {\n        return _this2._onAfterRepaint();\n      }); // Insert code into map's event pipeline\n\n      var fireEvent = map.fire;\n      map.fire = this._fireEvent.bind(this, fireEvent); // add listeners\n\n      map.on('resize', function () {\n        _this2._renderTransform.resize(map.transform.width, map.transform.height);\n      });\n      map.on('styledata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n      map.on('sourcedata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n\n      for (var eventName in pointerEvents) {\n        map.on(eventName, this._onPointerEvent);\n      }\n\n      for (var _eventName in cameraEvents) {\n        map.on(_eventName, this._onCameraEvent);\n      }\n\n      for (var _eventName2 in otherEvents) {\n        map.on(_eventName2, this._onEvent);\n      }\n\n      this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n\n  }, {\n    key: \"recycle\",\n    value: function recycle() {\n      Mapbox.savedMaps.push(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._map.remove();\n    } // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var map = this._map; // map._render will throw error if style does not exist\n      // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n      //   /src/ui/map.js#L1834\n\n      if (!this._inRender && map.style) {\n        // cancel the scheduled update\n        if (map._frame) {\n          map._frame.cancel();\n\n          map._frame = null;\n        } // the order is important - render() may schedule another update\n\n\n        map._render();\n      }\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n\n  }, {\n    key: \"_updateSize\",\n    value: function _updateSize(nextProps) {\n      // Check if size is controlled\n      var viewState = nextProps.viewState;\n\n      if (viewState) {\n        var map = this._map;\n\n        if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n          map.resize();\n          return true;\n        }\n      }\n\n      return false;\n    } // Adapted from map.jumpTo\n\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateViewState\",\n    value: function _updateViewState(nextProps, triggerEvents) {\n      if (this._internalUpdate) {\n        return false;\n      }\n\n      var map = this._map;\n      var tr = this._renderTransform; // Take a snapshot of the transform before mutation\n\n      var zoom = tr.zoom,\n          pitch = tr.pitch,\n          bearing = tr.bearing;\n      var changed = applyViewStateToTransform(tr, _objectSpread(_objectSpread({}, transformToViewState(map.transform)), nextProps));\n\n      if (changed && triggerEvents) {\n        var deferredEvents = this._deferredEvents; // Delay DOM control updates to the next render cycle\n\n        deferredEvents.move = true;\n        deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n        deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n        deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n      } // Avoid manipulating the real transform when interaction/animation is ongoing\n      // as it would interfere with Mapbox's handlers\n\n\n      if (!map.isMoving()) {\n        applyViewStateToTransform(map.transform, nextProps);\n      }\n\n      return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateSettings\",\n    value: function _updateSettings(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      var _iterator = _createForOfIteratorHelper(settingNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var propName = _step.value;\n\n          if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n            changed = true;\n            map[\"set\".concat(propName[0].toUpperCase()).concat(propName.slice(1))](nextProps[propName]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n\n  }, {\n    key: \"_updateStyle\",\n    value: function _updateStyle(nextProps, currProps) {\n      if (nextProps.cursor !== currProps.cursor) {\n        this._map.getCanvas().style.cursor = nextProps.cursor;\n      }\n\n      if (nextProps.mapStyle !== currProps.mapStyle) {\n        var options = {\n          diff: nextProps.styleDiffing\n        };\n\n        if ('localIdeographFontFamily' in nextProps) {\n          options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n        }\n\n        this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n\n        return true;\n      }\n\n      return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateStyleComponents\",\n    value: function _updateStyleComponents(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      if (map.style.loaded()) {\n        if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n          changed = true;\n          map.setLight(nextProps.light);\n        }\n\n        if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n          changed = true;\n          map.setFog(nextProps.fog);\n        }\n\n        if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n          if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n            changed = true;\n            map.setTerrain(nextProps.terrain); // Copy changes to the transform\n            // @ts-ignore\n\n            this._renderTransform.elevation = map.transform.elevation;\n          }\n        }\n      }\n\n      return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateHandlers\",\n    value: function _updateHandlers(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      var _iterator2 = _createForOfIteratorHelper(handlerNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n          var newValue = nextProps[propName];\n\n          if (!deepEqual(newValue, currProps[propName])) {\n            changed = true;\n\n            if (newValue) {\n              map[propName].enable(newValue);\n            } else {\n              map[propName].disable();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"_updateHover\",\n    value: function _updateHover(e) {\n      var props = this.props;\n      var shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n      if (shouldTrackHoveredFeatures) {\n        var _this$_hoveredFeature;\n\n        var eventType = e.type;\n        var wasHovering = ((_this$_hoveredFeature = this._hoveredFeatures) === null || _this$_hoveredFeature === void 0 ? void 0 : _this$_hoveredFeature.length) > 0;\n        var features;\n\n        if (eventType === 'mousemove') {\n          try {\n            features = this._map.queryRenderedFeatures(e.point, {\n              layers: props.interactiveLayerIds\n            });\n          } catch (_unused) {\n            features = [];\n          }\n        } else {\n          features = [];\n        }\n\n        var isHovering = features.length > 0;\n\n        if (!isHovering && wasHovering) {\n          e.type = 'mouseleave';\n\n          this._onPointerEvent(e);\n        }\n\n        this._hoveredFeatures = features;\n\n        if (isHovering && !wasHovering) {\n          e.type = 'mouseenter';\n\n          this._onPointerEvent(e);\n        }\n\n        e.type = eventType;\n      } else {\n        this._hoveredFeatures = null;\n      }\n    }\n  }, {\n    key: \"_fireEvent\",\n    value: function _fireEvent(baseFire, event, properties) {\n      var map = this._map;\n      var tr = map.transform;\n      var eventType = typeof event === 'string' ? event : event.type;\n\n      if (eventType === 'move') {\n        this._updateViewState(this.props, false);\n      }\n\n      if (eventType in cameraEvents) {\n        if (typeof event === 'object') {\n          event.viewState = transformToViewState(tr);\n        }\n\n        if (this._map.isMoving()) {\n          // Replace map.transform with ours during the callbacks\n          map.transform = this._renderTransform;\n          baseFire.call(map, event, properties);\n          map.transform = tr;\n          return map;\n        }\n      }\n\n      baseFire.call(map, event, properties);\n      return map;\n    } // All camera manipulations are complete, ready to repaint\n\n  }, {\n    key: \"_onBeforeRepaint\",\n    value: function _onBeforeRepaint() {\n      var _this3 = this;\n\n      var map = this._map; // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n\n      this._internalUpdate = true;\n\n      for (var eventType in this._deferredEvents) {\n        if (this._deferredEvents[eventType]) {\n          map.fire(eventType);\n        }\n      }\n\n      this._internalUpdate = false;\n      var tr = this._map.transform; // Make sure camera matches the current props\n\n      this._map.transform = this._renderTransform;\n\n      this._onAfterRepaint = function () {\n        // Restores camera state before render/load events are fired\n        _this3._map.transform = tr;\n      };\n    }\n  }], [{\n    key: \"reuse\",\n    value: function reuse(props, container) {\n      var that = Mapbox.savedMaps.pop();\n\n      if (!that) {\n        return null;\n      }\n\n      var map = that.map; // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n      // intoto the new container from the props.\n      // Step1: reparenting child nodes from old container to new container\n\n      var oldContainer = map.getContainer();\n      container.className = oldContainer.className;\n\n      while (oldContainer.childNodes.length > 0) {\n        container.appendChild(oldContainer.childNodes[0]);\n      } // Step2: replace the internal container with new container from the react component\n      // @ts-ignore\n\n\n      map._container = container; // Step 3: apply new props\n\n      if (props.initialViewState) {\n        that._updateViewState(props.initialViewState, false);\n      }\n\n      map.resize();\n      that.setProps(_objectSpread(_objectSpread({}, props), {}, {\n        styleDiffing: false\n      })); // Simulate load event\n\n      if (map.isStyleLoaded()) {\n        map.fire('load');\n      } else {\n        map.once('styledata', function () {\n          return map.fire('load');\n        });\n      }\n\n      return that;\n    }\n  }]);\n\n  return Mapbox;\n}();\n\nexport { Mapbox as default };\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\n\nfunction getAccessTokenFromEnv() {\n  var accessToken = null;\n  /* global location, process */\n\n  if (typeof location !== 'undefined') {\n    var match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  } // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n\n\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_unused2) {// ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_unused3) {// ignore\n  }\n\n  return accessToken;\n}","map":{"version":3,"mappings":"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","names":["transformToViewState","applyViewStateToTransform","normalizeStyle","deepEqual","pointerEvents","mousedown","mouseup","mouseover","mousemove","click","dblclick","mouseenter","mouseleave","mouseout","contextmenu","touchstart","touchend","touchmove","touchcancel","cameraEvents","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoom","zoomend","rotatestart","rotate","rotateend","pitchstart","pitch","pitchend","otherEvents","wheel","boxzoomstart","boxzoomend","boxzoomcancel","resize","load","render","idle","remove","data","styledata","sourcedata","error","settingNames","handlerNames","Mapbox","MapClass","props","container","e","cb","type","_updateHover","interactiveLayerIds","features","_hoveredFeatures","_map","queryRenderedFeatures","point","layers","length","_internalUpdate","_deferredEvents","_MapClass","_initialize","_renderTransform","oldProps","settingsChanged","_updateSettings","transform","clone","sizeChanged","_updateSize","viewStateChanged","_updateViewState","_updateStyle","_updateStyleComponents","_updateHandlers","isMoving","redraw","mapOptions","initialViewState","accessToken","mapboxAccessToken","getAccessTokenFromEnv","style","mapStyle","viewState","Object","assign","center","longitude","latitude","bearing","gl","getContext","HTMLCanvasElement","prototype","map","padding","setPadding","cursor","getCanvas","renderMap","_render","arg","_inRender","call","runRenderTaskQueue","_renderTaskQueue","run","_onBeforeRepaint","on","_onAfterRepaint","fireEvent","fire","_fireEvent","bind","width","height","eventName","_onPointerEvent","_onCameraEvent","_onEvent","savedMaps","push","_frame","cancel","nextProps","triggerEvents","tr","changed","deferredEvents","currProps","propName","toUpperCase","slice","options","diff","styleDiffing","localIdeographFontFamily","setStyle","loaded","light","setLight","fog","setFog","terrain","getSource","source","setTerrain","elevation","newValue","enable","disable","shouldTrackHoveredFeatures","onMouseMove","onMouseEnter","onMouseLeave","eventType","wasHovering","isHovering","baseFire","event","properties","that","pop","oldContainer","getContainer","className","childNodes","appendChild","_container","setProps","isStyleLoaded","once","location","match","exec","search","process","env","MapboxAccessToken","REACT_APP_MAPBOX_ACCESS_TOKEN"],"sources":["C:\\Users\\bhupe\\Downloads\\Term 4\\COMP4537\\MilestoneFinal\\ISAproject\\node_modules\\react-map-gl\\src\\mapbox\\mapbox.ts"],"sourcesContent":["import {transformToViewState, applyViewStateToTransform} from '../utils/transform';\nimport {normalizeStyle} from '../utils/style-utils';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {\n  Transform,\n  ProjectionSpecification,\n  ViewState,\n  ViewStateChangeEvent,\n  DragPanOptions,\n  ZoomRotateOptions,\n  TransformRequestFunction,\n  Light,\n  Fog,\n  TerrainSpecification,\n  MapboxStyle,\n  ImmutableLike,\n  LngLatBoundsLike,\n  FitBoundsOptions,\n  MapMouseEvent,\n  MapLayerMouseEvent,\n  MapLayerTouchEvent,\n  MapWheelEvent,\n  MapBoxZoomEvent,\n  MapStyleDataEvent,\n  MapSourceDataEvent,\n  MapboxEvent,\n  ErrorEvent,\n  MapboxGeoJSONFeature,\n  MapboxMap\n} from '../types';\n\nexport type MapboxProps = Partial<ViewState> & {\n  // Init options\n  mapboxAccessToken?: string;\n\n  /** Camera options used when constructing the Map instance */\n  initialViewState?: Partial<ViewState> & {\n    /** The initial bounds of the map. If bounds is specified, it overrides longitude, latitude and zoom options. */\n    bounds?: LngLatBoundsLike;\n    /** A fitBounds options object to use only when setting the bounds option. */\n    fitBoundsOptions?: FitBoundsOptions;\n  };\n\n  /** If provided, render into an external WebGL context */\n  gl?: WebGLRenderingContext;\n\n  /**\n   * If true, the gl context will be created with MSA antialiasing, which can be useful for antialiasing custom layers.\n   * This is false by default as a performance optimization.\n   * @default false\n   */\n  antialias?: boolean;\n  /**\n   * If true, an attribution control will be added to the map.\n   * @default true\n   */\n  attributionControl?: boolean;\n  /**\n   * Snap to north threshold in degrees.\n   * @default 7\n   */\n  bearingSnap?: number;\n  /**\n   * The max number of pixels a user can shift the mouse pointer during a click for it to be\n   * considered a valid click (as opposed to a mouse drag).\n   * @default 3\n   */\n  clickTolerance?: number;\n  /**\n   * If `true`, Resource Timing API information will be collected for requests made by GeoJSON\n   * and Vector Tile web workers (this information is normally inaccessible from the main\n   * Javascript thread). Information will be returned in a `resourceTiming` property of\n   * relevant `data` events.\n   * @default false\n   */\n  collectResourceTiming?: boolean;\n  /**\n   * If `true` , scroll zoom will require pressing the ctrl or ⌘ key while scrolling to zoom map,\n   * and touch pan will require using two fingers while panning to move the map.\n   * Touch pitch will require three fingers to activate if enabled.\n   */\n  cooperativeGestures?: boolean;\n  /**\n   * If `true`, symbols from multiple sources can collide with each other during collision\n   * detection. If `false`, collision detection is run separately for the symbols in each source.\n   * @default true\n   */\n  crossSourceCollisions?: boolean;\n  /** String or strings to show in an AttributionControl.\n   * Only applicable if options.attributionControl is `true`. */\n  customAttribution?: string | string[];\n  /**\n   * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.\n   * This setting affects all symbol layers. This setting does not affect the duration of runtime\n   * styling transitions or raster tile cross-fading.\n   * @default 300\n   */\n  fadeDuration?: number;\n  /** If true, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat?: boolean;\n  /** If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.\n   * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.\n   * An additional string may optionally be provided to indicate a parameter-styled hash,\n   * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo\n   * is a custom parameter and bar is an arbitrary hash distinct from the map hash.\n   */\n  hash?: boolean | string;\n  /** If false, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input\n   * @default true\n   */\n  interactive?: boolean;\n  /** A patch to apply to the default localization table for UI strings, e.g. control tooltips.\n   * The `locale` object maps namespaced UI string IDs to translated strings in the target language;\n   * see `src/ui/default_locale.js` for an example with all supported string IDs.\n   * The object may specify all UI strings (thereby adding support for a new translation) or\n   * only a subset of strings (thereby patching the default translation table).\n   */\n  locale?: {[key: string]: string};\n  /**\n   * Overrides the generation of all glyphs and font settings except font-weight keywords\n   * Also overrides localIdeographFontFamily\n   * @default null\n   */\n  localFontFamily?: string;\n  /**\n   * If specified, defines a CSS font-family for locally overriding generation of glyphs in the\n   * 'CJK Unified Ideographs' and 'Hangul Syllables' ranges. In these ranges, font settings from\n   * the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).\n   * The purpose of this option is to avoid bandwidth-intensive glyph server requests.\n   * @default \"sans-serif\"\n   */\n  localIdeographFontFamily?: string;\n  /**\n   * A string representing the position of the Mapbox wordmark on the map.\n   * @default \"bottom-left\"\n   */\n  logoPosition?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  /**\n   * The maximum number of tiles stored in the tile cache for a given source. If omitted, the\n   * cache will be dynamically sized based on the current viewport.\n   * @default null\n   */\n  maxTileCacheSize?: number;\n  /**\n   * If true, map will prioritize rendering for performance by reordering layers\n   * If false, layers will always be drawn in the specified order\n   * @default true\n   */\n  optimizeForTerrain?: boolean;\n  /**\n   * If `false`, the map's pitch (tilt) control with \"drag to rotate\" interaction will be disabled.\n   * @default true\n   */\n  pitchWithRotate?: boolean;\n  /** If true, The maps canvas can be exported to a PNG using map.getCanvas().toDataURL();. This is false by default as a performance optimization.\n   * @default false\n   */\n  preserveDrawingBuffer?: boolean;\n  /**\n   * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP\n   * `cacheControl`/`expires` headers.\n   * @default true\n   */\n  refreshExpiredTiles?: boolean;\n  /**\n   * Allows for the usage of the map in automated tests without an accessToken with custom self-hosted test fixtures.\n   * @default null\n   */\n  testMode?: boolean;\n  /**\n   * If  true, the map will automatically resize when the browser window resizes\n   * @default true\n   */\n  trackResize?: boolean;\n  /**\n   * A callback run before the Map makes a request for an external URL. The callback can be\n   * used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   * @default null\n   */\n  transformRequest?: TransformRequestFunction;\n\n  // Handlers\n\n  /**\n   * If true, enable the \"box zoom\" interaction (see BoxZoomHandler)\n   * @default true\n   */\n  boxZoom?: boolean;\n  /**\n   * If true, enable the \"double click to zoom\" interaction (see DoubleClickZoomHandler).\n   * @default true\n   */\n  doubleClickZoom?: boolean;\n  /**\n   * If `true`, the \"drag to pan\" interaction is enabled.\n   * An `Object` value is passed as options to {@link DragPanHandler#enable}.\n   * @default true\n   */\n  dragPan?: boolean | DragPanOptions;\n  /**\n   * If true, enable the \"drag to rotate\" interaction (see DragRotateHandler).\n   * @default true\n   */\n  dragRotate?: boolean;\n  /**\n   * If true, enable keyboard shortcuts (see KeyboardHandler).\n   * @default true\n   */\n  keyboard?: boolean;\n  /**\n   * If `true`, the \"scroll to zoom\" interaction is enabled.\n   * An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.\n   * @default true\n   */\n  scrollZoom?: boolean | ZoomRotateOptions;\n  /**\n   * If `true`, the \"drag to pitch\" interaction is enabled.\n   * An `Object` value is passed as options to {@link TouchPitchHandler#enable}.\n   * @default true\n   */\n  touchPitch?: boolean;\n  /**\n   * If `true`, the \"pinch to rotate and zoom\" interaction is enabled.\n   * An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.\n   * @default true\n   */\n  touchZoomRotate?: boolean | ZoomRotateOptions;\n\n  // Constraints\n\n  /** If set, the map is constrained to the given bounds. */\n  maxBounds?: LngLatBoundsLike;\n  /** Maximum pitch of the map. */\n  maxPitch?: number;\n  /** Maximum zoom of the map. */\n  maxZoom?: number;\n  /** Minimum pitch of the map. */\n  minPitch?: number;\n  /** Minimum zoom of the map. */\n  minZoom?: number;\n\n  /** For external controller to override the camera state */\n  viewState?: ViewState & {\n    width: number;\n    height: number;\n  };\n\n  // Styling\n\n  /** Mapbox style */\n  mapStyle?: string | MapboxStyle | ImmutableLike;\n  /** Enable diffing when the map style changes\n   * @default true\n   */\n  styleDiffing?: boolean;\n  /** The fog property of the style. Must conform to the Fog Style Specification .\n   * If `null` is provided, removes the fog from the map. */\n  fog?: Fog | null;\n  /** Light properties of the map. */\n  light?: Light;\n  /** Terrain property of the style. Must conform to the Terrain Style Specification .\n   * If `null` is provided, removes terrain from the map. */\n  terrain?: TerrainSpecification | null;\n  /** Default layers to query on pointer events */\n  interactiveLayerIds?: string[];\n  /** The projection the map should be rendered in\n   * @default \"mercator\"\n   */\n  projection?: ProjectionSpecification | string;\n  /**\n   * If `true`, multiple copies of the world will be rendered, when zoomed out.\n   * @default true\n   */\n  renderWorldCopies?: boolean;\n  /** CSS cursor */\n  cursor?: string;\n\n  // Callbacks\n  onMouseDown?: (e: MapLayerMouseEvent) => void;\n  onMouseUp?: (e: MapLayerMouseEvent) => void;\n  onMouseOver?: (e: MapLayerMouseEvent) => void;\n  onMouseMove?: (e: MapLayerMouseEvent) => void;\n  onClick?: (e: MapLayerMouseEvent) => void;\n  onDblClick?: (e: MapLayerMouseEvent) => void;\n  onMouseEnter?: (e: MapLayerMouseEvent) => void;\n  onMouseLeave?: (e: MapLayerMouseEvent) => void;\n  onMouseOut?: (e: MapLayerMouseEvent) => void;\n  onContextMenu?: (e: MapLayerMouseEvent) => void;\n  onTouchStart?: (e: MapLayerTouchEvent) => void;\n  onTouchEnd?: (e: MapLayerTouchEvent) => void;\n  onTouchMove?: (e: MapLayerTouchEvent) => void;\n  onTouchCancel?: (e: MapLayerTouchEvent) => void;\n\n  onMoveStart?: (e: ViewStateChangeEvent) => void;\n  onMove?: (e: ViewStateChangeEvent) => void;\n  onMoveEnd?: (e: ViewStateChangeEvent) => void;\n  onDragStart?: (e: ViewStateChangeEvent) => void;\n  onDrag?: (e: ViewStateChangeEvent) => void;\n  onDragEnd?: (e: ViewStateChangeEvent) => void;\n  onZoomStart?: (e: ViewStateChangeEvent) => void;\n  onZoom?: (e: ViewStateChangeEvent) => void;\n  onZoomEnd?: (e: ViewStateChangeEvent) => void;\n  onRotateStart?: (e: ViewStateChangeEvent) => void;\n  onRotate?: (e: ViewStateChangeEvent) => void;\n  onRotateEnd?: (e: ViewStateChangeEvent) => void;\n  onPitchStart?: (e: ViewStateChangeEvent) => void;\n  onPitch?: (e: ViewStateChangeEvent) => void;\n  onPitchEnd?: (e: ViewStateChangeEvent) => void;\n\n  onWheel?: (e: MapWheelEvent) => void;\n  onBoxZoomStart?: (e: MapBoxZoomEvent) => void;\n  onBoxZoomEnd?: (e: MapBoxZoomEvent) => void;\n  onBoxZoomCancel?: (e: MapBoxZoomEvent) => void;\n\n  onResize?: (e: MapboxEvent) => void;\n  onLoad?: (e: MapboxEvent) => void;\n  onRender?: (e: MapboxEvent) => void;\n  onIdle?: (e: MapboxEvent) => void;\n  onError?: (e: ErrorEvent) => void;\n  onRemove?: (e: MapboxEvent) => void;\n  onData?: (e: MapStyleDataEvent | MapSourceDataEvent) => void;\n  onStyleData?: (e: MapStyleDataEvent) => void;\n  onSourceData?: (e: MapSourceDataEvent) => void;\n};\n\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames: (keyof MapboxProps)[] = [\n  'minZoom',\n  'maxZoom',\n  'minPitch',\n  'maxPitch',\n  'maxBounds',\n  'projection',\n  'renderWorldCopies'\n];\nconst handlerNames: (keyof MapboxProps)[] = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate',\n  'touchPitch'\n];\n\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n  private _MapClass: typeof MapboxMap;\n  // mapboxgl.Map instance. Not using type here because we are accessing\n  // private members and methods\n  private _map: any = null;\n  // User-supplied props\n  props: MapboxProps;\n\n  // Mapbox map is stateful.\n  // During method calls/user interactions, map.transform is mutated and\n  // deviate from user-supplied props.\n  // In order to control the map reactively, we shadow the transform\n  // with the one below, which reflects the view state resolved from\n  // both user-supplied props and the underlying state\n  private _renderTransform: Transform;\n\n  // Internal states\n  private _internalUpdate: boolean = false;\n  private _inRender: boolean = false;\n  private _hoveredFeatures: MapboxGeoJSONFeature[] = null;\n  private _deferredEvents: {\n    move: boolean;\n    zoom: boolean;\n    pitch: boolean;\n    rotate: boolean;\n  } = {\n    move: false,\n    zoom: false,\n    pitch: false,\n    rotate: false\n  };\n\n  static savedMaps: Mapbox[] = [];\n\n  constructor(MapClass: typeof MapboxMap, props: MapboxProps, container: HTMLDivElement) {\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n\n  get map(): MapboxMap {\n    return this._map as MapboxMap;\n  }\n\n  get transform(): Transform {\n    return this._renderTransform;\n  }\n\n  setProps(props: MapboxProps) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n    if (settingsChanged) {\n      this._renderTransform = this._map.transform.clone();\n    }\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props, true);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props, oldProps);\n    this._updateHandlers(props, oldProps);\n\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n      this.redraw();\n    }\n  }\n\n  static reuse(props: MapboxProps, container: HTMLDivElement) {\n    const that = Mapbox.savedMaps.pop();\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n\n    // Step 3: apply new props\n    if (props.initialViewState) {\n      that._updateViewState(props.initialViewState, false);\n    }\n    map.resize();\n    that.setProps({...props, styleDiffing: false});\n\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n    return that;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _initialize(container: HTMLDivElement) {\n    const {props} = this;\n    const mapOptions = {\n      ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(props.mapStyle)\n    };\n\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map: any = new this._MapClass(mapOptions);\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n    this._renderTransform = map.transform.clone();\n\n    // Hack\n    // Insert code into map's render cycle\n    const renderMap = map._render;\n    map._render = (arg: number) => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n    map._renderTaskQueue.run = (arg: number) => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n      this._onBeforeRepaint();\n    };\n    map.on('render', () => this._onAfterRepaint());\n    // Insert code into map's event pipeline\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent);\n\n    // add listeners\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  recycle() {\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  }\n\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  _updateSize(nextProps: MapboxProps): boolean {\n    // Check if size is controlled\n    const {viewState} = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  _updateViewState(nextProps: MapboxProps, triggerEvents: boolean): boolean {\n    if (this._internalUpdate) {\n      return false;\n    }\n    const map = this._map;\n\n    const tr = this._renderTransform;\n    // Take a snapshot of the transform before mutation\n    const {zoom, pitch, bearing} = tr;\n    const changed = applyViewStateToTransform(tr, {\n      ...transformToViewState(map.transform),\n      ...nextProps\n    });\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents;\n      // Delay DOM control updates to the next render cycle\n      deferredEvents.move = true;\n      deferredEvents.zoom ||= zoom !== tr.zoom;\n      deferredEvents.rotate ||= bearing !== tr.bearing;\n      deferredEvents.pitch ||= pitch !== tr.pitch;\n    }\n\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!map.isMoving()) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateSettings(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n  _updateStyle(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const options: any = {\n        diff: nextProps.styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n      return true;\n    }\n    return false;\n  }\n\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateStyleComponents(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    const map = this._map;\n    let changed = false;\n    if (map.style.loaded()) {\n      if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n      if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n      if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n          // Copy changes to the transform\n          // @ts-ignore\n          this._renderTransform.elevation = map.transform.elevation;\n        }\n      }\n    }\n    return changed;\n  }\n\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateHandlers(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName];\n      if (!deepEqual(newValue, currProps[propName])) {\n        changed = true;\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n    return changed;\n  }\n\n  _onEvent = (e: MapboxEvent) => {\n    // @ts-ignore\n    const cb = this.props[otherEvents[e.type]];\n    if (cb) {\n      cb(e);\n    }\n  };\n\n  _updateHover(e: MapMouseEvent) {\n    const {props} = this;\n    const shouldTrackHoveredFeatures =\n      props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = this._hoveredFeatures?.length > 0;\n      let features;\n      if (eventType === 'mousemove') {\n        try {\n          features = this._map.queryRenderedFeatures(e.point, {\n            layers: props.interactiveLayerIds\n          });\n        } catch {\n          features = [];\n        }\n      } else {\n        features = [];\n      }\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _onPointerEvent = (e: MapLayerMouseEvent | MapLayerTouchEvent) => {\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      this._updateHover(e);\n    }\n\n    // @ts-ignore\n    const cb = this.props[pointerEvents[e.type]];\n    if (cb) {\n      if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n        const features =\n          this._hoveredFeatures ||\n          this._map.queryRenderedFeatures(e.point, {\n            layers: this.props.interactiveLayerIds\n          });\n        if (!features.length) {\n          return;\n        }\n        e.features = features;\n      }\n      cb(e);\n      delete e.features;\n    }\n  };\n\n  _onCameraEvent = (e: ViewStateChangeEvent) => {\n    if (!this._internalUpdate) {\n      // @ts-ignore\n      const cb = this.props[cameraEvents[e.type]];\n      if (cb) {\n        cb(e);\n      }\n    }\n    if (e.type in this._deferredEvents) {\n      this._deferredEvents[e.type] = false;\n    }\n  };\n\n  _fireEvent(baseFire: Function, event: string | MapboxEvent, properties?: object) {\n    const map = this._map;\n    const tr = map.transform;\n\n    const eventType = typeof event === 'string' ? event : event.type;\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        (event as ViewStateChangeEvent).viewState = transformToViewState(tr);\n      }\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n\n        return map;\n      }\n    }\n    baseFire.call(map, event, properties);\n\n    return map;\n  }\n\n  // All camera manipulations are complete, ready to repaint\n  _onBeforeRepaint() {\n    const map = this._map;\n\n    // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n    this._internalUpdate = true;\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n    this._internalUpdate = false;\n\n    const tr = this._map.transform;\n    // Make sure camera matches the current props\n    this._map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n\n  _onAfterRepaint: () => void;\n}\n\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv(): string {\n  let accessToken = null;\n\n  /* global location, process */\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  }\n\n  // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch {\n    // ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch {\n    // ignore\n  }\n\n  return accessToken;\n}\n"]},"metadata":{},"sourceType":"module"}